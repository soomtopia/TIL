## migration

서비스를 만들고 추가 컬럼을 만들거나, 컬럼 네임을 수정할경우 등의 이력 관리가 필요하다. 이걸 migration 파일로 작성 후 제공해준다

#### 초안 작성

```python
$ python3 manage.py makemigrations <app-name>
```

app-name 작성 시에는 해당 앱만 migrations 파일만 작성해준다. models 변경된 이력을 자동으로 app 내 migration 폴더 안에 추가해준다. 

##### makemigrations

명령어를 실행하면 바로 database 에 반영되는게 아닌 아래와 같이 제공해준다.

```python
# Generated by Django 2.2.6 on 2019-12-27 05:10

from django.db import migrations, models
import django.db.models.deletion


class Migration(migrations.Migration):

    initial = True

    dependencies = [
        ('posts', '__first__'),
    ]

    operations = [
        migrations.CreateModel(
            name='Image',
            fields=[
                ('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('created_at', models.DateTimeField(auto_now_add=True, verbose_name='작성시간')),
                ('url', models.ImageField(upload_to='image_directory_path', verbose_name='사진')),
                ('post', models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.CASCADE, related_name='images', to='posts.Post', verbose_name='게시글')),
            ],
            options={
                'ordering': ['created_at'],
            },
        ),
    ]

```

이후 작성된 내역이 맞다면, `migrate` 명령어를 통해 데이터 베이스에 반영할 수 있다.

##### 2-step 이 필요한경우

title 을 name 으로 변경했다고 가정하자. 이건 

- rename 

의 기능이지만,

- remove / add

의 작업으로 인식 할 수 있는 확률이 존재한다. remove 가 된다면 이전에 저장되어있던 게시글의 제목이 다 날라가는 불상사가 존재한다. migrate 전 해당 파일을 보고 변경된 사항이 잘 적용 되었는지 체크 후 저장하는게 안전하기 때문에 2-step 으로 진행되고 있다. 

##### 경험

daily-picture api 제작을 할 때 user 에 대한 이름이 예약어여서 model field 이름으로 지정되었을때 안바뀌는 현상이 나타났다. migation 파일에서 확인 후 변경을 하면 바로 해결 될 문제였는데 사용 방법을 잘 몰라 오래 고생했다. 마이그레이션 파일을 보고 이름이 변경되는지 잘 파악하자.



##### show migrations

마이그레이션 파일들이 적용된 범주를 확인해 줄 수 있다. 

```python
admin
 [X] 0001_initial
 [X] 0002_logentry_remove_auto_add
 [X] 0003_logentry_add_action_flag_choices
auth
 [X] 0001_initial
 [X] 0002_alter_permission_name_max_length
 [X] 0003_alter_user_email_max_length
 [X] 0004_alter_user_username_opts
 [X] 0005_alter_user_last_login_null
 [X] 0006_require_contenttypes_0002
 [X] 0007_alter_validators_add_error_messages
 [X] 0008_alter_user_username_max_length
 [X] 0009_alter_user_last_name_max_length
 [X] 0010_alter_group_name_max_length
 [X] 0011_update_proxy_permissions
blog
 [X] 0001_initial
contenttypes
 [X] 0001_initial
 [X] 0002_remove_content_type_name
dojo
 (no migrations)
sessions
 [X] 0001_initial
```

#### sqlmigrate

해당 마이그레이션 파일의 sql 내역을 볼 수 있다. databases s/w 마다 sql 문이 달라진다.

```
$ python manage.py sqlmigrate blog 0001

BEGIN;
-- Create model Post
CREATE TABLE "blog_post" ("id" integer NOT NULL PRIMARY KEY AUTOINCREMENT, "title" varchar(100) NOT NULL, "content" text NOT NULL, "tags" varchar(100) NOT NULL, "lnglat" varchar(50) NOT NULL, "created_at" datetime NOT NULL, "test_field" integer NOT NULL);
COMMIT;
```

#### Forward

마이그레이션 파일은 순차적으로 적용이된다. 

```
0001
0002
..
0006
0007 <
```

migrate 가 0007으로 지정이 되어있으나 , 0006으로 가고싶을 때

```python
$ python3 manage.py migrate blog 0006
```

으로 구분할 수 있는 파일로 구분을 하면, 해당 파일로 마이그레이션 작업이 이동된다. 

#### Backward

```python
$ python3 manage.py migrate zero
```

순차적으로 파일이 롤백이 된다. 

#### Require Field

모델 필드 옵션 중 blank, null 의 경우 모든 필드에서 지정되는 옵션이다. 

- blank (default = False)
- null (default = False)

이 값에 대한 필드가 지정이 된다면, 어떤 값을 채워 넣을지 설정해야한다.